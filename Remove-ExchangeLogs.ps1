<#
    .Synopsis
    Remove old Exchange server logs of various types (*.log, *.blg, and *.etl) to free up disk space.

    .Description
    Intended for Exchange Server 2013 and newer.  Configure a scheduled task on the Exchange server as follows:

    - When the task is running, use the following user account: .\SYSTEM
    - Action: Start a program
        -- Program/script: PowerShell
        -- Arguments: -File "<File path to script>" (e.g., -File "C:\.Scripts\Remove-ExchangeLogs.ps1")


    The script can be called with or without parameters specified.  It is recommended to just modify the default
    values assigned to the parameters in the param() block, making it easier to call the script with Task Scheduler.

    .Parameter MaxLogFileAge
    Specifies the max. age for Exchange server log files.  Older log files will be deleted.  Default = 30.

    .Parameter MaxCleanupLogFileAge
    Specifies the max. age for log files generated by this script.  Older logs will be deleted.  Default = 90.

    .Parameter ExLogFolderPaths
    Specifies one or more full folder paths to search for files with extensions *.log, *.blg, and *.etl.  Any found
    files that are older than the chosen threshold (MaxLogFileAge (default = 30)) will be deleted.
#>
#Requires -Version 4
[CmdletBinding()]
param(
    [int]$MaxLogFileAge = 30,
    [int]$MaxCleanupLogFileAge = 90,
    [ValidateScript(
        {
            if (Test-Path $_ -PathType Container) {$true} else {

                throw "Failed to validate folder path '$($_)'."
            }
        }
    )]
    [System.IO.FileInfo[]]$ExLogFolderPaths = @(
        # Modidy paths to match Exchange server's corresponding locations:
        'C:\inetpub\logs\LogFiles\',
        'C:\Program Files\Microsoft\Exchange Server\V15\Logging\',
        'C:\Program Files\Microsoft\Exchange Server\V15\Bin\Search\Ceres\Diagnostics\ETLTraces\',
        'C:\Program Files\Microsoft\Exchange Server\V15\Bin\Search\Ceres\Diagnostics\Logs'
    )
)

########-----------#
#region# Functions #
########-----------#

function writeLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string]$LogName,
        [Parameter(Mandatory)][datetime]$LogDateTime,
        [Parameter(Mandatory)][System.IO.FileInfo]$Folder,
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)][string]$Message,
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [switch]$DisableLogging,
        [switch]$PassThru
    )

    if (-not $DisableLogging -and -not $WhatIfPreference.IsPresent) {
        try {
            if (-not (Test-Path -Path $Folder)) {

                [void](New-Item -Path $Folder -ItemType Directory -ErrorAction Stop)
            }

            $LogFile = Join-Path -Path $Folder -ChildPath "$($LogName)_$($LogDateTime.ToString('yyyy-MM-dd_HH-mm-ss')).log"
            if (-not (Test-Path $LogFile)) {

                [void](New-Item -Path $LogFile -ItemType:File -ErrorAction Stop)
            }

            $Date = [datetime]::Now.ToString('yyyy-MM-dd hh:mm:ss tt')

            "[ $($Date) ] $($Message)" | Out-File -FilePath $LogFile -Append

            if ($PSBoundParameters.ErrorRecord) {

                # Format the error as it would be displayed in the PS console.
                "[ $($Date) ][Error] $($ErrorRecord.Exception.Message)`r`n" +
                "$($ErrorRecord.InvocationInfo.PositionMessage)`r`n" +
                "`t+ CategoryInfo: $($ErrorRecord.CategoryInfo.Category): " +
                "($($ErrorRecord.CategoryInfo.TargetName):$($ErrorRecord.CategoryInfo.TargetType))" +
                "[$($ErrorRecord.CategoryInfo.Activity)], $($ErrorRecord.CategoryInfo.Reason)`r`n" +
                "`t+ FullyQualifiedErrorId: $($ErrorRecord.FullyQualifiedErrorId)`r`n" |
                Out-File -FilePath $LogFile -Append -ErrorAction Stop
            }

            if ($PassThru) { $Message }
            else { Write-Verbose -Message $Message }
        }
        catch { throw }
    }
    else { Write-Verbose -Message $Message }
}

function Remove-ExchangeLogs ([System.IO.FileInfo[]]$ExLogFolderPaths, [int]$MaxLogFileAge) {
    try {
        writeLog @writeLogParams -Message "Remove-ExchangeLog starting: MaxLogFileAge = $($MaxLogFileAge), Folders to process:`r`n`t$($ExLogFolderPaths -join ""`r`n`t"")"

        foreach ($Folder in $ExLogFolderPaths) {

            writeLog @writeLogParams -Message "Processing folder: $($Folder)"

            if (Test-Path $Folder) {

                $FilesToDelete = Get-ChildItem -Path $Folder -Recurse -Include *.log, *.blg, *.etl |
                Where-Object {$_.LastWriteTime -le $dtNow.AddDays(-$MaxLogFileAge)}

                foreach ($File in $FilesToDelete) {

                    try {
                        Remove-Item $File.FullName -ErrorAction Stop | Out-Null
                        writeLog @writeLogParams -Message "Successfully deleted '$($File.FullName)'."
                    }
                    catch {
                        writeLog @writeLogParams -Message "Failed to delete '$($File.FullName)'.`r`n`tException:`r`n$($_.Exception)"
                    }
                }
            }
            else {
                writeLog @writeLogParams -Message "Folder '$($Folder)' was not found."
            }
        }

        writeLog @writeLogParams -Message 'Remove-ExchangeLog finished/ending.'
    }
    catch { throw }
}

function Remove-CleanupLogs ([int]$MaxCleanupLogFileAge) {
    try {
        writeLog @writeLogParams -Message "Housekeeping starting: MaxCleanupLogFileAge = $($MaxCleanupLogFileAge)"

        $CleanupLogsToDelete = Get-ChildItem -Path $writeLogparams.Folder -Filter "$($writeLogParams.LogName)*.log" |
        Where-Object {$_.LastWriteTime -le $dtNow.AddDays(-$MaxCleanupLogFileAge)}

        foreach ($CleanupLog in $CleanupLogsToDelete) {

            try {
                Remove-Item $CleanupLog.FullName -ErrorAction Stop | Out-Null
                writeLog @writeLogParams -Message "[Housekeeping] Successfully deleted '$($CleanupLog.FullName)'."
            }
            catch {
                writeLog @writeLogParams -Message "[Housekeeping] Failed to delete '$($CleanupLog.FullName)'.`r`n`tException:`r`n$($_.Exception)"
            }
        }

        writeLog @writeLogParams -Message 'Housekeeping finished/ending.'
    }
    catch { throw }
}

###########-----------#
#endregion# Functions #
###########-----------#



########----------------------------#
#region# Initialization & Variables #
########----------------------------#

# 1. writeLog splat and test writeLog:
$Script:dtNow = [datetime]::Now
$Script:writeLogParams = @{

    LogName     = "$($PSCmdlet.MyInvocation.MyCommand.Name -replace '\.ps1')"
    LogDateTime = $dtNow
    Folder      = "$($PSCmdlet.MyInvocation.MyCommand.Path -replace '\.ps1')_Logs"
    ErrorAction = 'Stop'
}
writeLog @writeLogParams -Message "$($PSCmdlet.MyInvocation.MyCommand.Name) - Start"
writeLog @writeLogParams -Message "MyCommand: $($PSCmdlet.MyInvocation.Line)"

###########----------------------------#
#endregion# Initialization & Variables #
###########----------------------------#



try {
    ########------------#
    #region# Processing #
    ########------------#

    Remove-ExchangeLogs -ExLogFolderPaths $ExLogFolderPaths -MaxLogFileAge $MaxLogFileAge
    Remove-CleanupLogs -MaxCleanupLogFileAge $MaxCleanupLogFileAge

    ###########------------#
    #endregion# Processing #
    ###########------------#
}
catch {
    writeLog @writeLogParams -Message 'Script-ending problem encountered.' -ErrorRecord $_ -PassThru | Write-Warning
    throw
}
finally {
    writeLog @writeLogParams -Message "$($PSCmdlet.MyInvocation.MyCommand.Name) - End"
}
